package hello;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import java.util.ArrayList;
import java.util.Optional;
import org.json.JSONObject;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/austinCleanupAPI") // This means URL's start with /demo (after Application path)
public class MainController {

	/*
	------------------------------------------------------------
	User Repository Interactions
	------------------------------------------------------------
	 */

	@Autowired // This means to get the bean called userRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;

	private Boolean isUser(String username){
		Iterable<User> user_list = userRepository.findAll();
		for(User u: user_list){
			if(u.getUsername().equals(username)){
				return true;
			}
		}
		return false;
	}

	//tests if the password meets minimum requirements
	private Boolean isStrongPassword(String password){
		if(password.length()<8) return false;

		Boolean hasNumber = false;
		Boolean hasUpper = false;
		Boolean hasNonAlpha = false;

		for(int i = 0; i<password.length(); i++){
			char c = password.charAt(i);
			if(c >= '0' && c <='9') hasNumber = true;
			if(c >= 'A' && c <='Z') hasUpper = true;
			if(!Character.isLetterOrDigit(c)) hasNonAlpha = true;
		}

		return hasUpper&&hasNumber&&hasNonAlpha;
	}

	//checks if username meets minimum requirements
	private Boolean isValidUsername(String username){
		if(username.length() > 3) return true;
		else return false;
	}

  private Boolean isValidEmail(String email){
		if(email.length() > 0) return true;
		else return false;
	}

  @CrossOrigin(origins = "http://localhost:3000")
	@PostMapping(path="/addUser") // Map ONLY POST Requests
	public @ResponseBody String addNewUser (@RequestBody String jsonStr) {

		// @ResponseBody means the returned String is the response, not a view name
		JSONObject jObject = new JSONObject(jsonStr);
		JSONObject retString = new JSONObject();
		String username = jObject.getString("username");
		String password = jObject.getString("password");
		String cpassword = jObject.getString("cpassword");
		String email = jObject.getString("email");

		//check that email is valid
		if(!isValidEmail(email)){
			retString.put("response", "Invalid email");
			return retString.toString();
		}
		//check passwords match
		if(!password.equals(cpassword)){
			retString.put("response", "Passwords do not match");
			return retString.toString();
		}

		//check that user does not already exist
		if(isUser(username)){
			retString.put("response", "User already exists");
			return retString.toString();
		}

		//check that is password is strong
		if(!isStrongPassword(password)){
			retString.put("response", "Password not strong enough");
			return retString.toString();
		}

		//check that is username is valid
		if(!isValidUsername(username)){
			retString.put("response", "Invalid username");
			return retString.toString();
		}

		User n = new User();
		n.setName("");
		n.setEmail(email);
		n.setUsername(username);
		n.setPassword(password);
		userRepository.save(n);
		retString.put("response", "User Saved");
		return retString.toString();
	}

	@PostMapping("/deleteUserById")
	public @ResponseBody String deleteUser(@RequestParam String id){

		// @RequestParam means it is a parameter from the GET or POST request
		userRepository.deleteById(Integer.parseInt(id));
		return "User Deleted";
	}

	@CrossOrigin(origins = "http://localhost:3000") //so we can make requests from react when in development revisit
	@GetMapping(path="/allUsers")
	public @ResponseBody Iterable<User> getAllUsers() {
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}

	@GetMapping(path="/userById")
	public @ResponseBody Optional<User> getUserById(@RequestParam String id){
		//returns info about an individual user by id
		return userRepository.findById(Integer.parseInt(id));
	}

	@CrossOrigin(origins="http://localhost:3000")
	@PostMapping(path="/checkIsUser")
	public @ResponseBody String checkIsUser(@RequestBody String jsonStr) {

		JSONObject jObject = new JSONObject(jsonStr);

		String username = jObject.getString("username");
		String password = jObject.getString("password");

		Iterable<User> user_list = userRepository.findAll();

		JSONObject retString = new JSONObject();

		for(User u: user_list){
			//the username string could also be an email
			if(u.getUsername().equals(username) || u.getEmail().equals(username)){
				if(u.getPassword().equals(password)){
					retString.put("IsValid", "True");
					retString.put("UserId", u.getId());
					return retString.toString();
				}
			}
		}

		retString.put("IsValid", "False");
		retString.put("UserId", "Null");
		return retString.toString();
	}


	/*
	------------------------------------------------------------
	Event Repository Interactions
	------------------------------------------------------------
	 */

	@Autowired //get the bean called eventRepository, we will use it to handle event data
	private EventRepository eventRepository;

	@CrossOrigin(origins = "http://localhost:3000")
	@PostMapping("/addEvent")
	public @ResponseBody String addEvent(@RequestBody String jsonStr){

		JSONObject jObject = new JSONObject(jsonStr);
		JSONObject retString = new JSONObject();

		Event n = new Event();
		n.setName(jObject.getString("name"));
		n.setAddress(jObject.getString("address"));
		n.setLatitude(Double.parseDouble(jObject.getString("latitude")));
		n.setLongitude(Double.parseDouble(jObject.getString("longitude")));
		n.setDescription(jObject.getString("description"));
		eventRepository.save(n);

		retString.put("EventId", Integer.toString(n.getId()));

		return retString.toString();
	}

	@PostMapping("/deleteEventById")
	public @ResponseBody String deleteEvent(@RequestParam String id){
		eventRepository.deleteById(Integer.parseInt(id));
		return "Event Deleted";
	}

	@CrossOrigin(origins = "http://localhost:3000") //so we can make requests from react when in development revisit
	@GetMapping("/allEvents")
	public @ResponseBody Iterable<Event> getAllEvents(){
		return eventRepository.findAll();
	}

	@CrossOrigin(origins = "http://localhost:3000") //so we can make requests from react when in development revisit
	@GetMapping("/eventById")
	public @ResponseBody Optional<Event> getEventById(@RequestParam String id){
		return eventRepository.findById(Integer.parseInt(id));
	}

	//not done, get list of events in a 10 mile radius of a latitude and longitude
	@CrossOrigin(origins = "http://localhost:3000") //so we can make requests from react when in development revisit
	@GetMapping("/eventsByLatLong")
	public @ResponseBody Iterable<Event> getEventsByLatLng(@RequestParam String lat, @RequestParam String lng){
		Iterable<Event> allEvents = eventRepository.findAll();
		ArrayList<Event> closeEvents = new ArrayList<Event>();

		Double in_lat = Double.parseDouble(lat);
		Double in_lng = Double.parseDouble(lng);

		//this is not perfect, ideally we would want to calculate by distance,
		//but the distance between longitudes at different latitudes is not constant
		//this will work for our small scale in texas
		Double DISTANCE_THRESHOLD = 10.0;
		for(Event event: allEvents){
			Double event_lat = event.getLatitude();
			Double event_lng = event.getLongitude();
			Double distance = Math.sqrt((event_lat-in_lat)*(event_lat-in_lat)+(event_lng-in_lng)*(event_lng-in_lng));
			if(distance < DISTANCE_THRESHOLD){
				closeEvents.add(event);
			}
		}

		return closeEvents;
  }

	/*
	------------------------------------------------------------
	UserEvent Repository Interactions
	This repository holds information about which users are associated
	with which events
	------------------------------------------------------------
	 */

	@Autowired
	private UserEventMapRepository userEventRepository;

	@CrossOrigin(origins = "http://localhost:3000")
	@PostMapping("/addUserEvent")
	public @ResponseBody String addUserEventInteraction(@RequestBody String jsonStr){

		JSONObject jObject = new JSONObject(jsonStr);

		UserEvent ue = new UserEvent();
		ue.setUserId(Integer.parseInt(jObject.getString("userId")));
		ue.setEventId(Integer.parseInt(jObject.getString("eventId")));
		ue.setOrganizer(Boolean.parseBoolean(jObject.getString("isOrganizer")));

		userEventRepository.save(ue);
		return "User/Event Mapping Saved";
	}

	@PostMapping("/deleteUserEventById")
	public @ResponseBody String deleteUserEventInteraction(@RequestParam String id){
		userEventRepository.deleteById(Integer.parseInt(id));
		return "User/Event Mapping Deleted";
	}

	@CrossOrigin(origins = "http://localhost:3000")
	@PostMapping("/deleteUserEvent")
	public @ResponseBody Boolean deleteUserEvent(@RequestBody String jsonStr){

		JSONObject jObject = new JSONObject(jsonStr);
		String userId = jObject.getString("userId");
		String eventId = jObject.getString("eventId");

		Iterable<UserEvent> all_user_events = userEventRepository.findAll();

		for(UserEvent ue: all_user_events){
			if(Integer.toString(ue.getEventId()).equals(eventId) && Integer.toString(ue.getUserId()).equals(userId)){
				if(!ue.getOrganizer()){
					userEventRepository.deleteById(ue.getId());
					return true;
				}else{
					//organizers should not be allowed to delete the event interaction
					//without deleting the overall event and other user event interactions
					return false;
				}
			}
		}

		return false;
	}

	@GetMapping("/allUserEvents")
	public @ResponseBody Iterable<UserEvent> getAllUserEvents(){
		return userEventRepository.findAll();
	}

	@GetMapping("/userEventById")
	public @ResponseBody Optional<UserEvent> getUserEventById(@RequestParam String id){
		return userEventRepository.findById(Integer.parseInt(id));
	}

	/*
	returns JSON string specifying if a user is signed up for an event
	and if the user is an organizer for the event
	*/
	@CrossOrigin(origins = "http://localhost:3000")
	@GetMapping("/isUserSignedUpForEvent")
	public @ResponseBody String isUserSignedUpForEvent(@RequestParam String userId, @RequestParam String eventId){
		Iterable<UserEvent> all_user_events = userEventRepository.findAll();
		JSONObject retString = new JSONObject();

		for(UserEvent ue: all_user_events){
			if(Integer.toString(ue.getEventId()).equals(eventId) &&
				 Integer.toString(ue.getUserId()).equals(userId)){
				retString.put("isSignedUp", true);
				if(ue.getOrganizer()){
					retString.put("isOrganizer", true);
				}else{
					retString.put("isOrganizer", false);
				}
				return retString.toString();
			}
		}

		retString.put("isSignedUp", false);
		retString.put("isOrganizer", false);
		return retString.toString();
	}

	@CrossOrigin(origins = "http://localhost:3000") //so we can make requests from react when in development revisit
	@GetMapping("/eventsByUserId")
	public @ResponseBody Iterable<Event> getEventsByUserId(@RequestParam String id){
		Iterable<UserEvent> all_user_events = userEventRepository.findAll();
		ArrayList<Event> my_user_events = new ArrayList<Event>();

		for(UserEvent ue: all_user_events){
			if(Integer.toString(ue.getUserId()).equals(id)){
				Optional<Event> potential_event = eventRepository.findById(ue.getEventId());
			  if(potential_event.isPresent()){
					my_user_events.add(potential_event.get());
				}
			}
		}

		return my_user_events;
	}

	//splits the events the user is associated with by those the user is an organizer
	//of and those they are not an organizer of
	@CrossOrigin(origins = "http://localhost:3000")
	@GetMapping("/detailedEventsByUserId")
	public @ResponseBody String getDetailedEventsByUserId(@RequestParam String id){
		Iterable<UserEvent> all_user_events = userEventRepository.findAll();
		ArrayList<Event> signed_up_events = new ArrayList<Event>();
		ArrayList<Event> organized_events = new ArrayList<Event>();

		for(UserEvent ue: all_user_events){
			if(Integer.toString(ue.getUserId()).equals(id)){
				Optional<Event> potential_event = eventRepository.findById(ue.getEventId());
				if(potential_event.isPresent()){
					if(ue.getOrganizer()){
						organized_events.add(potential_event.get());
					}else{
						signed_up_events.add(potential_event.get());
					}
				}
			}
		}

		JSONObject retString = new JSONObject();
		retString.put("signedUpEvents", signed_up_events);
		retString.put("organizedEvents", organized_events);

		return retString.toString();
	}

	/*
	------------------------------------------------------------
	Absolute Interactions
	commands that combine interactions between repositories
	------------------------------------------------------------
	*/

	//deletes an event from the event repository, and deletes all userEvents
	//that contain that event
	@CrossOrigin(origins = "http://localhost:3000")
	@PostMapping("/absoluteDeleteEventById")
	public @ResponseBody String absoluteDeleteEvent(@RequestBody String jsonStr){

		JSONObject jObject = new JSONObject(jsonStr);
		String id = jObject.getString("id");

		eventRepository.deleteById(Integer.parseInt(id));

		Iterable<UserEvent> all_user_events = userEventRepository.findAll();

		for(UserEvent ue: all_user_events){
			if(Integer.toString(ue.getEventId()).equals(id)){
				userEventRepository.deleteById(ue.getId());
			}
		}

		return "Event Absolutely Deleted";
	}


}
